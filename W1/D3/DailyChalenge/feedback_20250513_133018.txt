URL: https://github.com/IVSpector/DI-Bootcamp/blob/main/W1/D3/DailyChalenge/W1D3Cha.py
suggestions for improvement:
- Challenge 1: The code for Challenge 1 correctly implements the functionality described in the chapter content.  It uses a loop to iterate through the characters, dictionaries to store the data, and conditional statements to handle the addition of new keys or appending to existing lists. The use of `enumerate` is efficient and readable.  However, error handling (e.g., for non-alphabetic input) could be improved.
- Challenge 2: The code for Challenge 2 mostly meets the requirements but has a flaw in its logic. It subtracts the cost of each affordable item from the wallet amount. This means that if the sum of several inexpensive items exceeds the wallet amount, it won't correctly identify all affordable items.  It should check affordability of each item independently of others. The `replace()` method for cleaning the price string is efficient and functional. The sorting is correctly implemented. The error handling for an empty list is adequate.
- General:  Add docstrings to functions to enhance readability and maintainability. Use more descriptive variable names where appropriate (e.g., `affordable_items` instead of `list_name`). Consistent indentation is important for readability.
- Error Handling: Add error handling for cases where the input in challenge 2 is not in the expected format (e.g., non-numeric values in price).
- Challenge 2 Improvement: Refactor Challenge 2 to check affordability for each item individually, instead of cumulatively subtracting from the wallet.
Brief justification:
- correctness: The code mostly fulfills the requirements of both challenges. Challenge 1 perfectly addresses the letter index dictionary creation. Challenge 2's logic for handling cumulative spending needs to be fixed; otherwise, its basic functionality is present. This is why the score is 95% instead of 100%.  The chapter clearly outlines the expected input/output behavior, and the code largely adheres to it, except for the cumulative spending issue in Challenge 2.
- readability: The code is relatively easy to understand. However, using more descriptive variable names and adding comments would improve its readability. For example, `final_dict` could be `letter_index_dict`. The logic for price cleaning in Challenge 2 is a bit condensed and could benefit from clearer variable names.  This results in a 90% score.
- performance: The code is efficient for its purpose, particularly the use of `enumerate` in Challenge 1 and `replace()` in Challenge 2. The time complexity is linear for both. The algorithm's efficiency makes the score 95%. There's room for optimization only if we were to handle much larger inputs or scale up the processing for a very large number of items.
- security: The code doesn't have any obvious security vulnerabilities. It does not interact with external systems or handle user input in a way that would create security risks. Input sanitization is missing, but as the scope is limited to simple user input and not web-based interaction, this doesn't affect the 100% score.

